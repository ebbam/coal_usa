---
date: "`r Sys.Date()`"
author: Ebba Mark
title: "Typology Work New"
output: 
  html_document:
    theme: "lumen"
    code_download: true
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    df_print: paged
knit: (function(inputFile, encoding) { 
  rmarkdown::render(inputFile, 
  encoding = encoding, 
  output_format = "pdf_document", 
  output_dir = here::here("output")) 
  })
---
  
# Set-up
  
```{r, echo=FALSE}
knitr::opts_chunk$set(comment = NA, echo = TRUE, eval = TRUE, 
                      warning = FALSE, message = FALSE, 
                      fig.width = 6, fig.height = 4)
```

# Libraries
```{r, message = FALSE}

# core libraries
library(conflicted)
library(tidyverse)
library(readxl)
library(here)
library(kableExtra)
library(vtable)
library(cluster)   
library(factoextra)
library(flexclust)
library(xtable)
library(stargazer)
library(usmap)
library(ggplot2)
library(viridis)

conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
```
# Data
```{r,  echo=FALSE}
here::i_am("Final Data Products/final_df_2022full.xlsx")
typ_coal <- read_excel(here("Final Data Products/typ_coal.xlsx"))
typ_us <- read_excel(here("Final Data Products/typ_total_us.xlsx"))
typ_us <- subset(typ_us, fips != "11001")
final_cc <- read_excel(here("final_cc.xlsx"))

# Creates typology sheet using coal counties as identified in regression work
# final_cc has combined statistical area of Wise and Norton (fips: 51955) but 
# demographic characteristics are divided into Wise (fips: 51195) and Norton (fips: 51720)

cc <- subset(typ_us, typ_us$fips %in% final_cc$fips | typ_us$fips == 51195 | typ_us$fips == 51720)
cc_pdmif <- subset(typ_us, typ_us$fips %in% allcomp_pdmif$fips | typ_us$fips == 51195 | typ_us$fips == 51720)

```

# Analysis
```{r}
# Clustering on 251 coal counties claiming analysed in regression section
cluster_coal <- cc[,c("fips","RUC_2013","POPESTIMATE2019", 
                            "ed_over_25_bachelor_or_higher", "med_earnings",
                            "lfpr_20_64_female", "diversity_index")]

cluster_coal2 <- data.frame(cluster_coal, row.names = 1)
scaled_coalcluster <- scale(cluster_coal2)

# Indicates optimal clusters between 2-4
fviz_nbclust(scaled_coalcluster, hcut, method = "wss")

# Indicates optimal clusters 2
fviz_nbclust(scaled_coalcluster, hcut, method = "silhouette")

# Indicates optimal clusters 1
gap_stat <- clusGap(scaled_coalcluster, hcut, K.max = 10)
fviz_gap_stat(gap_stat)


res_k3 <- eclust(scaled_coalcluster, k = 3,  "hclust")
res_k3$size
fviz_cluster(res_k3)
cc <- data.frame(cc, res_k3$cluster)
names(cc)[names(cc) == "res_k3.cluster"] <- "cluster"

ct_voting <- function(clust) {
  n_clust = sum(with(cc, cc$cluster == clust))
  p_16 = sum(with(cc, party_16 == "REPUBLICAN" & cc$cluster == clust))
  p_20 =sum(with(cc, party == "REPUBLICAN" & cc$cluster == clust))
  if(p_16 == p_20) {return(p_16)}else{return(as.list[p_16,p_20])}
}

# Create table of cluster characteristics
cc_output <- as.data.frame(aggregate(cluster_coal2, by=list(cluster=res_k3$cluster), mean))
cc_output <- cbind(cc_output, res_k3$size)
cc_output <- as.data.frame(t(cc_output))
cc_output <- cc_output[, c(2, 1, 3)]
colnames(cc_output) = c("Type 1", "Type 2", "Type 3")
cc_output <- rbind(cc_output, c(ct_voting(2), ct_voting(1), ct_voting(3)))
typ_us$party[which(typ_us$fips == "06077")] = "DEMOCRAT"
us_avg <- t(summarize(typ_us, cluster = "us_total", mean(RUC_2013),mean(POPESTIMATE2019),mean(ed_over_25_bachelor_or_higher), mean(med_earnings), mean(lfpr_20_64_female), mean(diversity_index, na.rm = TRUE), nrow(typ_us), sum(party == "REPUBLICAN")))
cc_output1 <- cbind(cc_output, us_avg)

# NOTE THAT FIVE VIRGINIA COUNTIES ARE MISSING FROM THIS GROUP
typ_us$fips[which(is.na(typ_us$diversity_index))]
cc_output1 <- cc_output1[-1,]
print(cc_output1)

cluster_coal <- cc[,c("fips","RUC_2013","POPESTIMATE2019", 
                            "ed_over_25_bachelor_or_higher", "med_earnings",
                            "lfpr_20_64_female", "diversity_index", "party", "party_16")]

cluster_coal$party_20_bin <- ifelse(cluster_coal$party == "REPUBLICAN", 1, 0)
cluster_coal$party_16_bin <- ifelse(cluster_coal$party_16 == "REPUBLICAN", 1, 0)

stargazer(as.data.frame(cluster_coal[,c("RUC_2013","POPESTIMATE2019", 
                            "ed_over_25_bachelor_or_higher", "med_earnings",
                            "lfpr_20_64_female", "diversity_index", "party_20_bin", "party_16_bin")]), digits = 1,
          covariate.labels=c("2013 Rural-Urban Code","Population Size",
                             "Educational Attainment: Bachelor's Degree or Higher %; aged 25-64",
                             "Median Earnings USD","Female Labour Force Participation %; aged 25-64",
                             "Chmura Diversity Index", "Voted for the Republican Party in the 2020 Election", "Voted for the Republican Party in the 2020 Election"), notes = "* The number of coal counties included in the typology (252) differs from the number identified in the econometric analysis (251) because Wise County, Virginia and Norton City, Virginia  are considered separately by the various entities reporting data for the typology characteristics. They are combined into one county area by the Bureau of Economic Analysis whose method was used as the standard used for the econometric analysis.")
```

# Clustering on 237 coal counties suggested from PDMIF work 

```{r}


cluster_coal_pdmif <- cc_pdmif[,c("fips","RUC_2013","POPESTIMATE2019", 
                            "ed_over_25_bachelor_or_higher", "med_earnings",
                            "lfpr_20_64_female", "diversity_index")]

cluster_coal3 <- data.frame(cluster_coal_pdmif, row.names = 1)
pdmifscaled_coalcluster <- scale(cluster_coal3)

# Indicates optimal clusters between 2-4
fviz_nbclust(pdmifscaled_coalcluster, hcut, method = "wss")

# Indicates optimal clusters 2
fviz_nbclust(pdmifscaled_coalcluster, hcut, method = "silhouette")

# Indicates optimal clusters 1
gap_stat <- clusGap(pdmifscaled_coalcluster, hcut, K.max = 10)
fviz_gap_stat(gap_stat)


res2_k3 <- eclust(pdmifscaled_coalcluster, k = 3,  "hclust")
res2_k3$size
fviz_cluster(res2_k3)
cc_pdmif <- data.frame(cc_pdmif, res2_k3$cluster)
names(cc_pdmif)[names(cc_pdmif) == "res2_k3.cluster"] <- "cluster"

ct_voting <- function(clust) {
  n_clust = sum(with(cc, cc$cluster == clust))
  p_16 = sum(with(cc, party_16 == "REPUBLICAN" & cc$cluster == clust))
  p_20 =sum(with(cc, party == "REPUBLICAN" & cc$cluster == clust))
  if(p_16 == p_20) {return(p_16)}else{return(as.list[p_16,p_20])}
}

# Create table of cluster characteristics
cc_pdmif_output <- as.data.frame(aggregate(cluster_coal3, by=list(cluster=res2_k3$cluster), mean))
cc_pdmif_output <- cbind(cc_pdmif_output, res2_k3$size)
cc_pdmif_output <- as.data.frame(t(cc_pdmif_output))
cc_pdmif_output <- cc_pdmif_output[, c(2, 1, 3)]
colnames(cc_pdmif_output) = c("Type 1", "Type 2", "Type 3")
cc_pdmif_output <- rbind(cc_pdmif_output, c(ct_voting(2), ct_voting(1), ct_voting(3)))
typ_us$party[which(typ_us$fips == "06077")] = "DEMOCRAT"
us_avg <- t(summarize(typ_us, cluster = "us_total", mean(RUC_2013),mean(POPESTIMATE2019),mean(ed_over_25_bachelor_or_higher), mean(med_earnings), mean(lfpr_20_64_female), mean(diversity_index, na.rm = TRUE), nrow(typ_us), sum(party == "REPUBLICAN")))
cc_output2 <- cbind(cc_pdmif_output, us_avg)

# NOTE THAT FIVE VIRGINIA COUNTIES ARE MISSING FROM THIS GROUP
typ_us$fips[which(is.na(typ_us$diversity_index))]
cc_output2 <- cc_output2[-1,]
print(cc_output2)

cluster_coal_pdmif <- cc_pdmif[,c("fips","RUC_2013","POPESTIMATE2019", 
                            "ed_over_25_bachelor_or_higher", "med_earnings",
                            "lfpr_20_64_female", "diversity_index", "party", "party_16")]

cluster_coal_pdmif$party_20_bin <- ifelse(cluster_coal_pdmif$party == "REPUBLICAN", 1, 0)
cluster_coal_pdmif$party_16_bin <- ifelse(cluster_coal_pdmif$party_16 == "REPUBLICAN", 1, 0)


```



```{r}
cluster_map <- read_excel(here("Final Data Products/cc_clusters_251.xlsx"))
cluster_map <- cc
cluster_map$type = 0
cluster_map$type[which(cluster_map$cluster == 1)] = 2
cluster_map$type[which(cluster_map$cluster == 2)] = 1
cluster_map$type[which(cluster_map$cluster == 3)] = 3

pdmif_map <- subset(cluster_map, fips %in% allcomp_pdmif$fips)
cluster_map$type = as.factor(cluster_map$type)


plot_usmap(data = pdmif_map, values = "type", regions = "counties", col = "gray90", size = 0.04, exclude = c("AK", "HI" )) + 
  scale_fill_viridis_d(name = "County Type", labels = c("Type 1", "Type 2", "Type 3", "No active mines 2002-2019"), na.value = "gray80") +
    theme(panel.background = element_rect(color = "white", fill = "white"), text = element_text(family = "Times New Roman", color = "gray10"),
          plot.title = element_text(face = "bold"), legend.background=element_blank())

plot_usmap(data = cluster_map, values = "type", regions = "counties", col = "gray90", size = 0.04, exclude = c("AK", "HI" )) + 
  scale_fill_viridis_d(name = "County Type", labels = c("Type 1", "Type 2", "Type 3", "No active mines 2002-2019"), na.value = "gray80") +
    theme(panel.background = element_rect(color = "white", fill = "white"), text = element_text(family = "Times New Roman", color = "gray10"),
          plot.title = element_text(face = "bold"), legend.background=element_blank())

allcomp_pdmif <- subset(allcomp_cc_types, !(fips %in% const_fips))

ggsave("County_types_252.jpg", units="in", width=9, height=6, dpi=300)
```

# Create df with clusters for regressions
```{r}
cc_cluster <- cc[c("fips", "cluster")]
cc_cluster$type[which(cc_cluster$cluster == 1)] = 2
cc_cluster$type[which(cc_cluster$cluster == 2)] = 1
cc_cluster$type[which(cc_cluster$cluster == 3)] = 3

cc_cluster$fips[which(cc_cluster$fips == "51195" | cc_cluster$fips == "51720")] <- "51955"
cc_cluster <- cc_cluster[!duplicated(cc_cluster$fips),]

# writexl::write_xlsx(cc_cluster, here("Final Data Products/cc_clusters_251.xlsx"))
```


# Testing on Oil and Gas
```{r, eval = FALSE, include = FALSE}

# NEED TO REMOVE HAWAII, ALASKA, DC!

cluster_og <- typ_og[,c("fips","RUC_2013","POPESTIMATE2019", "ed_over_25_bachelor_or_higher", "med_earnings","lfpr_20_64_female", "diversity_index")]
writexl::write_xlsx(cluster_og, "/Users/ebbamark/OneDrive - Nexus365/Ebba Dissertation Materials/Final Data Products/cluster_og.xlsx")
cluster_og2 <- data.frame(cluster_og, row.names = 1)
scaled_ogcluster <- scale(cluster_og2)


# Indicates optimal clusters 2-5
fviz_nbclust(scaled_ogcluster, hcut, method = "wss")

# Indicates optimal clusters 2
fviz_nbclust(scaled_ogcluster, hcut, method = "silhouette")

# Indicates optimal clusters 3
gap_stat <- clusGap(scaled_ogcluster, hcut, K.max = 10)
fviz_gap_stat(gap_stat)

# Automatically produces list of 3 clusters
res_kog <- eclust(scaled_ogcluster, "hclust")
res_kog$size
aggregate(cluster_og, by=list(cluster=res_kog$cluster), mean)
fviz_cluster(res_kog)

typ_og <- data.frame(typ_og, as.factor(res_kog$cluster))
#typ_og$og_clustertype = as.factor(typ_og$res_kog.cluster)

typ_og <- data.frame(typ_og, res_kog$cluster)


```

# Testing on entire country
```{r}

typ_total_us <- subset(typ_total_us, substr(fips, 1,2) != "02" & substr(fips, 1,2) != "15" & fips != "11001")
typ_total_us <- subset(typ_total_us, !is.na(typ_total_us$diversity_index))
cluster_usa <- typ_total_us[,c("fips","RUC_2013","POPESTIMATE2019", "ed_over_25_bachelor_or_higher", "med_earnings","lfpr_20_64_female", "diversity_index")]
cluster_usa <- subset(cluster_usa, !is.na(cluster_usa$diversity_index))
writexl::write_xlsx(cluster_usa, "/Users/ebbamark/OneDrive - Nexus365/Ebba Dissertation Materials/Final Data Products/cluster_usa.xlsx")

cluster_usa2 <- data.frame(cluster_usa, row.names = 1)
scaled_uscluster <- scale(cluster_usa2)

#scaled_uscoal <- subset(scaled_uscluster, row.names(scaled_uscluster) %in% cluster_mines$fips)


# Indicates optimal clusters 2 - 6
fviz_nbclust(scaled_uscluster, hcut, method = "wss")

# Indicates optimal clusters 2
fviz_nbclust(scaled_uscluster, hcut, method = "silhouette")

# Indicates optimal clusters 3
gap_stat <- clusGap(scaled_uscluster, hcut, B = 50, K.max = 10)
fviz_gap_stat(gap_stat)

# Automatically produces list of 3 clusters
res_usa <- eclust(scaled_uscluster, "hclust", k = 3)
res_usa$size
aggregate(cluster_usa, by=list(cluster=res_usa$cluster), mean)
fviz_cluster(res_usa)

typ_total_us <- data.frame(typ_total_us, res_usa$cluster)
typ_total_us$us_clustertype = as.factor(typ_total_us$res_usa.cluster)

colMeans(cluster_usa[,-1])

sum(is.na(typ_total_us$party_16))

# 167
sum(typ_total_us$party_16 == "DEMOCRAT" & res_usa$cluster == 1)
# 103
sum(typ_total_us$party_16 == "DEMOCRAT" & res_usa$cluster == 2)
# 214
sum(typ_total_us$party_16 == "DEMOCRAT" & res_usa$cluster == 3)


```


```{r, eval = FALSE, include = FALSE}

# Clustering on mines only: NEED TO REMOVE HAWAII FROM CLUSTER_MINES!

cluster_mines2 <- data.frame(cluster_mines, row.names = 1)
scaled_minescluster <- scale(cluster_mines2)

writexl::write_xlsx(cluster_mines, "/Users/ebbamark/OneDrive - Nexus365/Ebba Dissertation Materials/Final Data Products/cluster_mines.xlsx")

library(stargazer)

# stargazer(as.data.frame(select(cluster_mines, -1, -8)), digits = 1, 
#           covariate.labels=c("2013 Rural-Urban Code","Population Size",
#                              "Educational Attainment: Bachelor's Degree or Higher (%; aged 25-64)",
#                              "Median Earnings (USD)","Female Labour Force Participation (%; aged 25-64)",
#                              "Chmura Diversity Index"))
# 
# stargazer(as.data.frame(cluster_usa2), digits = 1, covariate.labels=c("2013 Rural-Urban Code","Population Size",
#                              "Educational Attainment: Bachelor's Degree or Higher (%; aged 25-64)",
#                              "Median Earnings (USD)","Female Labour Force Participation (%; aged 25-64)",
#                              "Chmura Diversity Index"))

# # Indicates optimal clusters 3-4
fviz_nbclust(scaled_minescluster, hcut, method = "wss")
# 
# # Indicates optimal clusters 2
fviz_nbclust(scaled_minescluster, hcut, method = "silhouette")
# 
# # Indicates optimal clusters 1
gap_stat <- clusGap(scaled_minescluster, hcut, K.max = 10)
fviz_gap_stat(gap_stat)


res_mines3 <- eclust(scaled_minescluster, k = 3,  "hclust")
res_mines3$size
aggregate(cluster_mines2, by=list(cluster=res_mines3$cluster), mean)
mines_means <- aggregate(cluster_mines, by=list(cluster=res_mines3$cluster), mean)

mines_means <- data.frame(mines_means, row.names = 1)
mines_means <- mines_means[,c("fips","RUC_2013","POPESTIMATE2019", "ed_over_25_bachelor_or_higher", "med_earnings","lfpr_20_64_female", "diversity_index")]
fviz_cluster(res_mines3)

cluster_mines <- data.frame(cluster_mines, res_mines3$cluster)

names(cluster_mines)[names(cluster_mines) == "res_mines3.cluster"] <- "type"

euclidean <- function(a, b) {sqrt(sum((a - b)^2))}

cluster_usa2 <- data.frame(cluster_usa, row.names = 1)
mines_means2 <- mines_means[,-1]

usa_types <- data.frame(matrix(ncol = 2, nrow = 3136))
for (i in (1:nrow(cluster_usa2))) {
  ft = row.names(cluster_usa2[i,])
  print(ft)
  usa_types$fips[i] = ft
  if (ft %in% cluster_mines$fips) {
    usa_types$type[i] = cluster_mines$type[which(cluster_mines$fips == ft)]
    print("in")
  } else if (!(ft %in% cluster_mines$fips)) {
    print("ok")
  # calculate euclidean distance to cluster 1
    dist1 = euclidean(cluster_usa2[i,], mines_means2[1,])
  # calculate euclidean distance to cluster 2
    dist2 = euclidean(cluster_usa2[i,], mines_means2[2,])
  # calculate euclidean distance to cluster 3
    dist3 = euclidean(cluster_usa2[i,], mines_means2[3,])
  # find min of previous assignments
      if (min(dist1, dist2, dist3) == dist1) {usa_types$type[i] = 1
      } else if (min(dist1, dist2, dist3) == dist2) {usa_types$type[i] = 2
      } else if (min(dist1, dist2, dist3) == dist3) {usa_types$type[i] = 3}
    
  } else {print("failed")}
}

#test they are the same
cluster_mines <- subset(cluster_mines, fips != "02068")

for (i in (1:nrow(cluster_mines))) {
  print(i)
  ftest = cluster_mines$fips[i]
  print(ftest)
  typetest = usa_types$type[which(usa_types$fips == ftest)]
  print(typetest)
  if (cluster_mines$type[i] !=  typetest) {print(0)}
}

aggregate(cluster_usa, by=list(cluster=res_usa$cluster), mean)

table(cluster_mines['type'])

#11 counties voted Democrat
dem = 0
#141 counties voted Republican
rep = 0
for (j in (1:nrow(cluster_mines))) {
  print(j)
  partytest = cluster_mines$fips[j]
  print(partytest)
  ptest = typ_total_us$type[which(usa_types$fips == ftest)]
  if (typ_total_us$party_16[which(typ_total_us$fips == partytest)] == "DEMOCRAT")
  {dem = dem + 1}
  if (typ_total_us$party_16[which(typ_total_us$fips == partytest)] == "REPUBLICAN")
  {rep = rep + 1}
  else {print("warning")}
}


```


```{r, eval = FALSE, include = FALSE}

cluster_mines$type_trans = 0
cluster_mines$type_trans[which(cluster_mines$type == 1)] = 1
cluster_mines$type_trans[which(cluster_mines$type == 2)] = 3
cluster_mines$type_trans[which(cluster_mines$type == 3)] = 2


cluster_mines$cluster_type_trans = as.factor(cluster_mines$type_trans)

plot_usmap(data = cluster_mines, values = "cluster_type_trans", regions = "counties", col = "black", size = 0.07, exclude = c("AK", "HI" )) + 
  scale_fill_manual(name = "Cluster Type", labels = c("Type 1", "Type 2", "Type 3", "No active mines in 2019"), values = c("sienna3",  "palegreen4", "darkblue"), na.value = "seashell2") +
  theme(panel.background = element_rect(color = "black", fill = "white"))
 

typ_og$res_kog.cluster <- as.factor(typ_og$res_kog.cluster)
plot_usmap(data = typ_og, values = "res_kog.cluster", regions = "counties", col = "black", size = 0.05) + 
  labs(title = "Geographical Distribution of Oil and Gas County Types") + 
    scale_fill_discrete(name = "Cluster Type", na.value = "white") + 
  theme(panel.background = element_rect(color = "black", fill = "white"))

plot_usmap(data = typ_og, values = "res_kog.cluster", regions = "counties", col = "black", size = 0.05) + 
  labs(title = "Geographical Distribution of Oil and Gas County Types",
       subtitle = "Each of the aforementioned oil and gas county types is outlined above and denoted below by distinct colors.") + 
    scale_fill_discrete(name = "Cluster Type", na.value = "white") + 
  theme(panel.background = element_rect(color = "black", fill = "gray90"))

plot_usmap(data = typ_total_us, values = "us_clustertype", regions = "counties", col = "black", size = 0.05) + 
  labs(title = "Geographical Distribution of Overall US County Types",
       subtitle = "Each of the aforementioned US county types is outlined above and denoted below by distinct colors.") + 
    scale_fill_discrete(name = "Cluster Type", na.value = "white") + 
  theme(panel.background = element_rect(color = "black", fill = "gray90"))

```

